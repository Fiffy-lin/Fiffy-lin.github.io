---
layout: post
title: "刷题记录-寻找重复数"
subtitle: ""
date: 2021-11-25
author: "Fiffy"
header-img: "img/post-bg-2015.jpg"
tags: []
---

# 题目

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 1 到 `n` 之间（包括 1 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 一个重复的整数 ，找出 这个重复的数 。

你设计的解决方案必须不修改数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

示例 1：

```
输入：nums = [1,3,4,2,2]
输出：2
```

示例 2：

```
输入：nums = [3,1,3,4,2]
输出：3
```

示例 3：

```
输入：nums = [1,1]
输出：1
```

示例 4：

```
输入：nums = [1,1,2]
输出：1
```


提示：

- `1 <= n <= 10^5`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次

# 思路

O(1) 空间复杂度还不让修改原数组，直接把排序的路封死了。

题解用了 Floyd 判圈法，链表里面 有环，即 一个节点 被不同的 节点指向（映射）； 而 这里说的 数组 有环，即 数组中的一个元素值 被不同的 index 指向（映射）； 所以，求解方法 一样可以 使用 快慢指针法。

把下标和数字都想象成链表中的节点，有重复数字，说明一定有两个下标指向一个数字。同时数字范围决定了数字 0 一定不会被某个下标指向，因此 0 可以作为链表起点。

关于 Floyd 判圈法：设链表起点到环起点距离为 a，环起点到快慢指针相遇点为 b，相遇点到环起点为 c，则快指针在慢指针走 (a+b) 时了走了 2(a+b). 同时快指针走的路也可以写作 a+b+k(b+c)，可以解出来 a = k(b+c) - b = (k-1)(b+c) + c。 因此再让慢指针走 a 长度，快指针会走 k-1 个环加上 c。让慢指针从头出发，快指针从相遇点出发，就能在环起点相遇。

# 代码

```c++
class Solution {
public:
    int findDuplicate(vector<int> &nums) {
        int fast = 0, slow = 0;
        do {
            fast = nums[nums[fast]];
            slow = nums[slow];
        } while (fast != slow);
        slow = 0;
        while (fast != slow) {
            fast = nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
};
```

