---
layout: post
title: "刷题记录-放置盒子"
subtitle: ""
date: 2021-11-23
author: "Fiffy"
header-img: "img/post-bg-2015.jpg"
tags: ["Leetcode"]
---

# 题目

有一个立方体房间，其长度、宽度和高度都等于 `n` 个单位。请你在房间里放置 `n` 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下：

你可以把盒子放在地板上的任何地方。
如果盒子 `x` 需要放置在盒子 `y` 的顶部，那么盒子 `y` 竖直的四个侧面都 必须 与另一个盒子或墙相邻。
给你一个整数 `n` ，返回接触地面的盒子的 最少 可能数量。

 

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/3-boxes.png)

```
输入：n = 3
输出：3
解释：上图是 3 个盒子的摆放位置。
这些盒子放在房间的一角，对应左侧位置。
```

示例 2：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/4-boxes.png)

```
输入：n = 4
输出：3
解释：上图是 3 个盒子的摆放位置。
这些盒子放在房间的一角，对应左侧位置。
```

示例 3：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/24/10-boxes.png)

```
输入：n = 10
输出：6
解释：上图是 10 个盒子的摆放位置。
这些盒子放在房间的一角，对应后方位置。
```


提示：

- `1 <= n <= 10^9`

# 思路

首先先堆成最密堆，就像上面的例二和例三的图一样。这种堆每一层的数量可以看出来是 `1, 3, 6, ...` 每一层的数量 `f(n) = f(n-1) + n` 。

堆成最密堆之后，我们再把剩下的放进去。用图表示放入过程：

1. 一开始，最密堆是这样的

   | 3    | 2    | 1    |
   | ---- | ---- | ---- |
   | 2    | 1    |      |
   | 1    |      |      |

2. 放入第一个新的，放在最下面

   | 3    | 2    | 1    |      |
   | ---- | ---- | ---- | ---- |
   | 2    | 1    |      |      |
   | 1    |      |      |      |
   | 1    |      |      |      |

3. 放入第二、第三个。第二个放在从下往上数第二行，由于放入了这个，左侧的格子上面一层也能多放一个了

   | 3    | 2    | 1    |      |
   | ---- | ---- | ---- | ---- |
   | 2    | 1    |      |      |
   | 2    | 1    |      |      |
   | 1    |      |      |      |

4. 放入第四五六个，原理和上面一样

   | 3    | 2    | 1    |      |
   | ---- | ---- | ---- | ---- |
   | 3    | 2    | 1    |      |
   | 2    | 1    |      |      |
   | 1    |      |      |      |

5. 放入第七八九十个，变成多一层的最密堆

   | 4    | 3    | 2    | 1    |
   | ---- | ---- | ---- | ---- |
   | 3    | 2    | 1    |      |
   | 2    | 1    |      |      |
   | 1    |      |      |      |

可以看出来，放入过程中每次放入的数量是 `1, 2, 3, 4 ....` ，每次放入只会让 `n` 增加一个。

# 代码

```c++
class Solution {
public:
    int minimumBoxes(int n) {
        int k = 1;
        int sum = 0;
        while (sum + (k * (k + 1)) / 2 < n) {
            sum = sum + (k * (k + 1)) / 2;
            k++;
        }
        k--;
        int res = (k * (k + 1)) / 2;
        k = 1;
        while (sum < n) {
            sum = sum + k;
            k++;
            res++;
        }
        return res;
    }
};
```

