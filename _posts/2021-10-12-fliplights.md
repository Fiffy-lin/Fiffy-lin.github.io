---
layout: post
title: "刷题记录-灯泡开关 Ⅱ"
subtitle: ""
date: 2021-10-12
author: "Fiffy"
header-img: "img/post-bg-2015.jpg"
tags: ["Leetcode","数学"]
---

# 题目

现有一个房间，墙上挂有 `n` 只已经打开的灯泡和 4 个按钮。在进行了 `m` 次未知操作后，你需要返回这 `n` 只灯泡可能有多少种不同的状态。

假设这 `n` 只灯泡被编号为 `[1, 2, 3 ..., n]`，这 4 个按钮的功能如下：

- 将所有灯泡的状态反转（即开变为关，关变为开）
- 将编号为偶数的灯泡的状态反转
- 将编号为奇数的灯泡的状态反转
- 将编号为 `3k+1` 的灯泡的状态反转（k = 0, 1, 2, ...) 

示例 1:

```
输入: n = 1, m = 1.
输出: 2
说明: 状态为: [开], [关]
```


示例 2:

```
输入: n = 2, m = 1.
输出: 3
说明: 状态为: [开, 关], [关, 开], [关, 关]
```


示例 3:

```
输入: n = 3, m = 1.
输出: 4
说明: 状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].
```


注意： n 和 m 都属于 [0, 1000].

# 思路

前三个灯的状态可以唯一确定所有灯的状态。
按二号三号按钮时，奇数跟着 1 一起变，偶数跟着 2 一起变，因此可以复制 1/2 的状态得到所有灯的状态。观察 1 和 3 的状态是否相同，如果不一样，说明四号按钮按过了，再把 3k+1 反一下。

# 代码

```c++
class Solution {
public:
    int flipLights(int n, int presses) {
        // 前三个灯的状态可以唯一确定所有灯的状态。
        // 按二号三号按钮时，奇数跟着 1 一起变，偶数跟着 2 一起变
        // 可以复制 1/2 的状态得到所有灯的状态
        // 观察 1 和 3 的状态是否相同，如果不一样，说明四号按钮按过了，再把 3k+1 反一下
        // 所以给定前三个灯的状态，可以唯一得到所有 n 个灯的状态
        n = min(n, 3);
        vector<vector<int>> m_n_to_ans(3, vector<int>(3));
        // 按一次，可能的组合有 (0,0,0) (1,0,1) (0,1,0) (0,1,1)
        m_n_to_ans[0] = {2, 3, 4};
        // 按两次，(1,1,1) (1,0,1) (0,1,0) (1,0,0) (0,0,1) (0,0,0) (1,1,0)
        m_n_to_ans[1] = {2, 4, 7};
        // 按三次，可以得到 3 个灯的全部 8 种状态组合
        m_n_to_ans[2] = {2, 4, 8};
        // 可能的状态数已经顶满了，再往上按也就这么多了
        presses = min(presses, 3);
        return presses == 0 ? 1 : m_n_to_ans[presses - 1][n - 1];
    }
};
```

