---
layout: post
title: "刷题记录-路径总和 III"
subtitle: ""
date: 2021-09-29
author: "Fiffy"
header-img: "img/post-bg-2015.jpg"
tags: ["Leetcode","前缀和","DFS"]
---

# 题目

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

示例 1：

![](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

示例 2：

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```


提示:

- 二叉树的节点个数的范围是 [0,1000]
- `-10^9 <= Node.val <= 10^9`
- `-1000 <= targetSum <= 1000`

# 思路

最先想到的肯定是 DFS 暴力，当前节点和子节点的总数 = 左节点包含前面节点的数量 + 右节点包含前面节点的数量 + 左节点可以不包含前面节点的数量 + 右节点可以不包含前面节点的数量 + 当前节点是否合法。

也可以用前缀和来做，结合前序遍历，就转换成了数组中求连续子数组和等于某个值的问题。如果`路径 A 的和 - targetSum == 路径 B 的和`，那么 `A` 到 `B` 的路径就是符合要求的路径。注意要先累积答案，再把当前节点的数量放进哈希表里。因为如果 `targetSum == 0`，那么 `prevSum - targetSum` 就一定等于 `prevSum` ，相当于路径没有元素。这显然不符合累积答案的要求。

# 代码

```c++
class Solution_recursive {
public:
    int pathSum(TreeNode *root, int targetSum, bool usePrev = false) {
        if (!root) return 0;
        int ans = pathSum(root->left, targetSum - root->val, true);
        ans += pathSum(root->right, targetSum - root->val, true);
        if (!usePrev) {
            ans += pathSum(root->left, targetSum, false);
            ans += pathSum(root->right, targetSum, false);
        }
        ans += (targetSum == root->val);
        return ans;
    }
};
```

```c++
class Solution {
public:
    unordered_map<int, int> sumToCount;
    int ans = 0;

    void preOrder(TreeNode *curr, int prevSum, int targetSum) {
        if (!curr) return;
        prevSum += curr->val;
        if (sumToCount.count(prevSum - targetSum)) ans += sumToCount[prevSum - targetSum];
        sumToCount[prevSum]++;
        preOrder(curr->left, prevSum, targetSum);
        preOrder(curr->right, prevSum, targetSum);
        sumToCount[prevSum]--;
    }

    int pathSum(TreeNode *root, int targetSum) {
        sumToCount[0] = 1;
        preOrder(root, 0, targetSum);
        return ans;
    }

};
```

